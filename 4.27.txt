*정적배열 : 초기에 사이즈가 고정되어 있음.

*동적배열 : 사이즈가 얼마나 될지 모를때 사용. 그러나 데이터를 담을 그릇이 필요할때.

*일반적인 상황에선 정적배열보다 동적배열 사용.

* 배열의 자료를 어떻게 활용하느냐에 따라 배열 / 연결리스트 사용 나뉨.

* 동적배열 - 그릇을 새로 만들고 이전 배열 다시 복사 후 추가 - 비용발생
	  - 중간에 데이터 삽입/추가 시에도 옆의 데이터들을 이동시켜야함.
* 링크드리스트 : 그릇이 연결.. - 데이터의 추가/삭제시 다른 데이터의 이동 없음. - 추가/삭제가 더 빠름.  - 데이터 삽입/삭제가 빈번하게 일어날때 사용.
		단점 : 배열은 한개의 메모리 영역, 인덱스로 접근하여 빠르지만, 연결 리스트는 접근 속도가 느림.
		배열의 단점을 보완하기 위해 나온 자료구조.

* 스택/큐 : 데이터 넣고,빼는 목적
* 해시셋 : 데이터 조회 목적

* 스택 : 배열로 구현 - 데이터의 이동이 적으므로.
* 해시셋 : 배열은 조회가 오래걸림. 이를 보완하기 위해 나온것. value자체가 key. 해시함수를 통해 해시값.. 해시충돌발생., 최소충돌..
	중복값 검사시 주로 사용.. 교집합 찾을때.. 
* 딕셔너리 : key(속성), value(값) 로 구성. key로 value를 찾음. 


* string -> object : 박싱
* object -> string : 언박싱


* 제너릭 열거자 : 서로 다른 자료구조(배열, 연결리스트, 해시..) - 동일한 목적 구현 - 출력 목록을 인터페이스로 받고, 약속된 메소드 호출... - 함수 하나만 만들어도 됨.
인터페이스를 작은 목적단위로 만들고 구현.

* foreach 사용할 수 있는 클래스를 만들기 위해서는 IEnumerable, IEnumerator 인터페이스를 상속하고 이들에게 선언되어 있는 메소드와 프로퍼티를 구현해야함.
  하지만, 요소를 순회할 때마다 형변환을 수행하는 오버로드 발생하는 문제점 => 



-------------------------------------------------------------
3.1 형식 같음 비교자 인터페이스의 이해
* IEqualityComparer 인터페이스 : ***다양한 형식***의 두 **객체**가 같은지 비교하는 메소드 제공.
  EqualityComparer<T> 클래스를 상속하는 것을 권장.

* string 형식의 기본 비교(Equals) 로직 :  대소문자를 구분하는 것으로로 구현 
-> 바꾸고 싶으면 IEqualityComparer 쓰면 됨. (string은 내가 만든 클래스 아니므로 오버라이딩 불가능하기 때문)

* -able 인터페이스 : ~할 수 있는(내 스스로 능력이 있는 것.)
* -er, -or : 내가 아닌 다른 것을 조종하는 것.